// Объявляем пространство имён проекта ассемблера — логическая группировка кода
namespace Assembler
{
    // Объявляем публичный класс Parser, который будет обрабатывать ассемблерный код
    public class Parser
    {
        // Метод принимает массив строк исходного .asm-файла и возвращает только значимые инструкции без пробелов и комментариев
        public string[] RemoveWhitespacesAndComments(string[] asmLines)
        {
            // Защита от null: если входной массив не задан, возвращаем пустой массив (а не null), чтобы избежать ошибок далее
            if (asmLines == null)
                return new string[0];

            // Создаём динамический список для накопления очищенных строк (количество заранее неизвестно)
            var cleanLines = new System.Collections.Generic.List<string>();

            // Проходим по каждой строке входного массива — обрабатываем по одной
            foreach (string line in asmLines)
            {
                // Находим позицию первого вхождения "//" (начало комментария); если нет — вернёт -1
                int commentStart = line.IndexOf("//");

                // Извлекаем только часть строки до комментария (если комментарий есть), иначе берём всю строку
                string codePart = commentStart >= 0 ? line.Substring(0, commentStart) : line;

                // Удаляем все пробелы из оставшейся части строки, чтобы инструкции были "плотными" (например, "@10", "D=M")
                string noSpaces = codePart.Replace(" ", "");

                // Если после удаления пробелов строка не пустая — значит, в ней есть реальная инструкция
                if (noSpaces != "")
                {
                    // Добавляем эту инструкцию в список очищенных строк
                    cleanLines.Add(noSpaces);
                }
            }

            // Преобразуем список в массив и возвращаем результат — готовый набор "чистых" инструкций для дальнейшего парсинга
            return cleanLines.ToArray();
        }
    }
}
