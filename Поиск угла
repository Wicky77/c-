using System;
using NUnit.Framework;

namespace Manipulation;

public class TriangleTask
{
    /// <summary>
    /// Возвращает угол (в радианах) между сторонами a и b в треугольнике со сторонами a, b, c 
    /// </summary>
    public static double GetABAngle(double a, double b, double c)
    {
        if (double.IsNaN(a) || double.IsNaN(b) || double.IsNaN(c) ||
            double.IsInfinity(a) || double.IsInfinity(b) || double.IsInfinity(c) ||
            a<0 || b<0 || c<0)
            return double.NaN;

        if (a==0 || b==0)
            return double.NaN;

        double cosAngle = (a*a+b*b-c*c) / (2*a*b);

        const double epsilon = 1e-12;
        if (cosAngle < -1-epsilon || cosAngle > 1+epsilon)
            return double.NaN;

        cosAngle = Math.Max(-1.0, Math.Min(1.0, cosAngle));
        return Math.Acos(cosAngle);
    }
}

[TestFixture]
public class TriangleTask_Tests
{
    [TestCase(3, 4, 5, Math.PI/2)]        
    [TestCase(1, 1, 1, Math.PI/3)]        
    [TestCase(2, 2, 4, Math.PI)]           
    [TestCase(5, 5, 0, 0.0)]               
    [TestCase(10, 10, 10, Math.PI/3)]   
    public void TestGetABAngle(double a, double b, double c, double expectedAngle)
    {
        double actual = TriangleTask.GetABAngle(a, b, c);
        Assert.That(actual, Is.EqualTo(expectedAngle).Within(1e-10));
	}

    [TestCase(0, 1, 1)]
    [TestCase(1, 0, 1)]
    [TestCase(-1, 2, 3)]
    [TestCase(1, 2, -3)]
    [TestCase(double.NaN, 1, 1)]
    [TestCase(1, double.PositiveInfinity, 1)]
    [TestCase(1, 1, 10)] 
    public void InvalidInputs_ReturnNaN(double a, double b, double c)
    {
        Assert.That(double.IsNaN(TriangleTask.GetABAngle(a, b, c)));
    }
}
