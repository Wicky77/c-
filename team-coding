using System;
using System.Collections.Generic;
using System.Linq;

// ---------- –ö–ª–∞—Å—Å –∑–∞–¥–∞—á–∏ ----------
public class Task
{
    public int ID { get; set; }
    public string Name { get; set; }
    public int Duration { get; set; }
    public int Priority { get; set; }
    public List<int> Dependencies { get; set; } = new List<int>();
}

// ---------- –ú–µ–Ω–µ–¥–∂–µ—Ä –ø—Ä–æ–µ–∫—Ç–∞ ----------
public class ProjectManager
{
    private Dictionary<int, Task> _tasks = new Dictionary<int, Task>();

    public void AddTask(Task task)
    {
        if (task == null) throw new ArgumentNullException(nameof(task));
        if (task.Duration < 0) throw new ArgumentException("–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å >= 0");
        if (task.Priority < 1 || task.Priority > 5) throw new ArgumentException("–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç 1-5");
        if (_tasks.ContainsKey(task.ID)) throw new ArgumentException("ID —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç");
        if (task.Dependencies.Distinct().Count() != task.Dependencies.Count())
            throw new ArgumentException("–î—É–±–ª–∏–∫–∞—Ç—ã –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—è—Ö –∑–∞–ø—Ä–µ—â–µ–Ω—ã");

        foreach (int dep in task.Dependencies)
            if (!_tasks.ContainsKey(dep))
                throw new ArgumentException($"–ó–∞–≤–∏—Å–∏–º–æ—Å—Ç—å {dep} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞");

        if (WouldIntroduceCycle(task))
            throw new ArgumentException("–¶–∏–∫–ª–∏—á–µ—Å–∫–∞—è –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å");

        _tasks[task.ID] = task;
    }

    private bool WouldIntroduceCycle(Task newTask)
    {
        var visited = new HashSet<int>();
        return HasPathTo(newTask.ID, newTask.Dependencies, visited);
    }

    private bool HasPathTo(int target, IEnumerable<int> start, HashSet<int> visited)
    {
        foreach (int id in start)
        {
            if (id == target) return true;
            if (visited.Contains(id)) continue;
            visited.Add(id);
            if (_tasks.TryGetValue(id, out var t) && HasPathTo(target, t.Dependencies, visited))
                return true;
        }
        return false;
    }

    public List<Task> ListAllTasks() => _tasks.Values.ToList();
    public Task FindTask(int id) => _tasks.GetValueOrDefault(id);

    public List<int> TopologicalSort()
    {
        var inDegree = _tasks.Keys.ToDictionary(id => id, _ => 0);
        var graph = _tasks.Keys.ToDictionary(id => id, _ => new List<int>());

        foreach (var task in _tasks.Values)
        {
            foreach (int dep in task.Dependencies)
            {
                graph[dep].Add(task.ID);
                inDegree[task.ID]++;
            }
        }

        var queue = new Queue<int>(_tasks.Keys.Where(id => inDegree[id] == 0));
        var result = new List<int>();

        while (queue.Count > 0)
        {
            int u = queue.Dequeue();
            result.Add(u);
            foreach (int v in graph[u])
            {
                if (--inDegree[v] == 0)
                    queue.Enqueue(v);
            }
        }

        if (result.Count != _tasks.Count)
            throw new InvalidOperationException("–¶–∏–∫–ª –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—è—Ö");
        return result;
    }

    // === –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô –ú–ï–¢–û–î –ö–†–ò–¢–ò–ß–ï–°–ö–û–ì–û –ü–£–¢–ò ===
    public (List<int> path, int duration) CalculateCriticalPath()
    {
        if (_tasks.Count == 0) return (new List<int>(), 0);

        var topo = TopologicalSort();
        var earliestStart = _tasks.Keys.ToDictionary(id => id, _ => 0);
        var earliestFinish = new Dictionary<int, int>(); // ‚Üê –ö–õ–Æ–ß–ï–í–û: —Ö—Ä–∞–Ω–∏–º finish!
        var predecessor = new Dictionary<int, int>();

        // –ü—Ä–æ—Ö–æ–¥–∏–º –ø–æ –∑–∞–¥–∞—á–∞–º –≤ —Ç–æ–ø–æ–ª–æ–≥–∏—á–µ—Å–∫–æ–º –ø–æ—Ä—è–¥–∫–µ
        foreach (int taskId in topo)
        {
            // –í—Ä–µ–º—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è = –≤—Ä–µ–º—è –Ω–∞—á–∞–ª–∞ + –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
            int finishTime = earliestStart[taskId] + _tasks[taskId].Duration;
            earliestFinish[taskId] = finishTime;

            // –û–±–Ω–æ–≤–ª—è–µ–º –∑–∞–¥–∞—á–∏, –∫–æ—Ç–æ—Ä—ã–µ –∑–∞–≤–∏—Å—è—Ç –æ—Ç —Ç–µ–∫—É—â–µ–π
            foreach (int dependentId in _tasks.Keys.Where(id => _tasks[id].Dependencies.Contains(taskId)))
            {
                // –ï—Å–ª–∏ –Ω–æ–≤–æ–µ –≤—Ä–µ–º—è –Ω–∞—á–∞–ª–∞ –±–æ–ª—å—à–µ —Ç–µ–∫—É—â–µ–≥–æ ‚Äî –æ–±–Ω–æ–≤–ª—è–µ–º
                if (earliestStart[dependentId] < finishTime)
                {
                    earliestStart[dependentId] = finishTime;
                    predecessor[dependentId] = taskId;
                }
            }
        }

        // –ù–∞—Ö–æ–¥–∏–º –∑–∞–¥–∞—á—É —Å –ú–ê–ö–°–ò–ú–ê–õ–¨–ù–´–ú –≤—Ä–µ–º–µ–Ω–µ–º –ó–ê–í–ï–†–®–ï–ù–ò–Ø
        var lastTask = earliestFinish.Aggregate((x, y) => x.Value > y.Value ? x : y);
        int totalDuration = lastTask.Value;

        // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—É—Ç—å
        var path = new List<int>();
        int current = lastTask.Key;
        while (true)
        {
            path.Add(current);
            if (!predecessor.TryGetValue(current, out int pred)) break;
            current = pred;
        }
        path.Reverse();

        return (path, totalDuration);
    }

    public string VisualizeDependencies()
    {
        if (_tasks.Count == 0) return "–ù–µ—Ç –∑–∞–¥–∞—á.";
        var roots = _tasks.Keys.Where(id => !_tasks[id].Dependencies.Any()).ToList();
        var visited = new HashSet<int>();
        var lines = new List<string>();

        void Dfs(int id, int depth)
        {
            if (!visited.Add(id)) return;
            lines.Add($"{new string(' ', depth * 2)}{id}: {_tasks[id].Name}");
            foreach (var next in _tasks.Keys.Where(next => _tasks[next].Dependencies.Contains(id)))
                Dfs(next, depth + 1);
        }

        foreach (int root in roots) Dfs(root, 0);
        foreach (int id in _tasks.Keys.Except(visited))
            lines.Add($"[Orphan] {id}: {_tasks[id].Name}");

        return string.Join("\n", lines);
    }
}

// ---------- –û—Å–Ω–æ–≤–Ω–∞—è –ø—Ä–æ–≥—Ä–∞–º–º–∞ ----------
class Program
{
    static void Main()
    {
        var manager = new ProjectManager();
        int choice;

        Console.WriteLine("=== –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –°–∏—Å—Ç–µ–º—É —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø—Ä–æ–µ–∫—Ç–∞–º–∏! ===\n");

        do
        {
            Console.WriteLine("=== –°–∏—Å—Ç–µ–º–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø—Ä–æ–µ–∫—Ç–∞–º–∏ ===");
            Console.WriteLine("1. –î–æ–±–∞–≤–∏—Ç—å –∑–∞–¥–∞—á—É");
            Console.WriteLine("2. –ü–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ –∑–∞–¥–∞—á–∏");
            Console.WriteLine("3. –¢–æ–ø–æ–ª–æ–≥–∏—á–µ—Å–∫–∞—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞");
            Console.WriteLine("4. –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–π –ø—É—Ç—å");
            Console.WriteLine("5. –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π");
            Console.WriteLine("6. –í—ã—Ö–æ–¥");
            Console.Write("–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ: ");

            if (!int.TryParse(Console.ReadLine(), out choice) || choice < 1 || choice > 6)
            {
                Console.WriteLine("\n‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –≤—ã–±–æ—Ä! –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.\n");
                continue;
            }

            switch (choice)
            {
                case 1:
                    AddTask(manager);
                    break;
                case 2:
                    ShowTasks(manager);
                    break;
                case 3:
                    ShowTopoSort(manager);
                    break;
                case 4:
                    ShowCriticalPath(manager);
                    break;
                case 5:
                    ShowDependencies(manager);
                    break;
                case 6:
                    Console.WriteLine("\n‚úÖ –í—ã—Ö–æ–¥ –∏–∑ —Å–∏—Å—Ç–µ–º—ã. –î–æ —Å–≤–∏–¥–∞–Ω–∏—è!");
                    return;
            }

            Console.WriteLine("\n" + new string('-', 50) + "\n");

        } while (choice != 6);
    }

    static void AddTask(ProjectManager manager)
    {
        try
        {
            Console.Write("\nID: ");
            int id = int.Parse(Console.ReadLine());
            Console.Write("–ù–∞–∑–≤–∞–Ω–∏–µ: ");
            string name = Console.ReadLine();
            Console.Write("–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å (—á): ");
            int dur = int.Parse(Console.ReadLine());
            Console.Write("–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç (1-5): ");
            int prio = int.Parse(Console.ReadLine());

            Console.Write("–ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ (—á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é, –∏–ª–∏ Enter): ");
            var depsInput = Console.ReadLine();
            var deps = string.IsNullOrWhiteSpace(depsInput)
                ? new List<int>()
                : depsInput.Split(',').Select(int.Parse).ToList();

            manager.AddTask(new Task { ID = id, Name = name, Duration = dur, Priority = prio, Dependencies = deps });
            Console.WriteLine("‚úÖ –ó–∞–¥–∞—á–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∞!");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"‚ùå –û—à–∏–±–∫–∞: {ex.Message}");
        }
    }

    static void ShowTasks(ProjectManager manager)
    {
        var tasks = manager.ListAllTasks();
        if (!tasks.Any())
        {
            Console.WriteLine("\n–ù–µ—Ç –∑–∞–¥–∞—á.");
            return;
        }

        Console.WriteLine("\nID | –ù–∞–∑–≤–∞–Ω–∏–µ                | –î–ª–∏—Ç | –ü—Ä–∏–æ—Ä | –ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏");
        Console.WriteLine("-------------------------------------------------------------");
        foreach (var t in tasks.OrderBy(t => t.ID))
        {
            string deps = t.Dependencies.Any() ? string.Join(",", t.Dependencies) : "‚Äî";
            Console.WriteLine($"{t.ID,-3}| {t.Name,-24}| {t.Duration,4} | {t.Priority,5} | {deps}");
        }
    }

    static void ShowTopoSort(ProjectManager manager)
    {
        try
        {
            var order = manager.TopologicalSort();
            Console.WriteLine($"\n–ü–æ—Ä—è–¥–æ–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è (—Ç–æ–ø–æ—Å–æ—Ä—Ç): {string.Join(" ‚Üí ", order)}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"‚ùå {ex.Message}");
        }
    }

    static void ShowCriticalPath(ProjectManager manager)
    {
        try
        {
            var (path, dur) = manager.CalculateCriticalPath();
            Console.WriteLine($"\nüöÄ –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–π –ø—É—Ç—å: {string.Join(" ‚Üí ", path)}");
            Console.WriteLine($"‚è±Ô∏è –û–±—â–∞—è –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: {dur} —á");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"‚ùå {ex.Message}");
        }
    }

    static void ShowDependencies(ProjectManager manager)
    {
        Console.WriteLine("\nüå≥ –î–µ—Ä–µ–≤–æ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π:");
        Console.WriteLine(manager.VisualizeDependencies());
    }
}
